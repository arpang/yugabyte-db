--
-- Tests for pg15 branch stability.
--
-- Basics
create table t1 (id int, name text);
create table t2 (id int primary key, name text);
explain (COSTS OFF) insert into t2 values (1);
  QUERY PLAN  
--------------
 Insert on t2
   ->  Result
(2 rows)

insert into t2 values (1);
explain (COSTS OFF) insert into t2 values (2), (3);
           QUERY PLAN            
---------------------------------
 Insert on t2
   ->  Values Scan on "*VALUES*"
(2 rows)

insert into t2 values (2), (3);
explain (COSTS OFF) select * from t2 where id = 1;
           QUERY PLAN           
--------------------------------
 Index Scan using t2_pkey on t2
   Index Cond: (id = 1)
(2 rows)

select * from t2 where id = 1;
 id | name 
----+------
  1 | 
(1 row)

explain (COSTS OFF) select * from t2 where id > 1;
        QUERY PLAN         
---------------------------
 Seq Scan on t2
   Remote Filter: (id > 1)
(2 rows)

select * from t2 where id > 1;
 id | name 
----+------
  2 | 
  3 | 
(2 rows)

explain (COSTS OFF) update t2 set name = 'John' where id = 1;
  QUERY PLAN  
--------------
 Update on t2
   ->  Result
(2 rows)

update t2 set name = 'John' where id = 1;
explain (COSTS OFF) update t2 set name = 'John' where id > 1;
           QUERY PLAN            
---------------------------------
 Update on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

update t2 set name = 'John' where id > 1;
explain (COSTS OFF) update t2 set id = id + 4 where id = 1;
              QUERY PLAN              
--------------------------------------
 Update on t2
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = 1)
(3 rows)

update t2 set id = id + 4 where id = 1;
explain (COSTS OFF) update t2 set id = id + 4 where id > 1;
           QUERY PLAN            
---------------------------------
 Update on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

update t2 set id = id + 4 where id > 1;
explain (COSTS OFF) delete from t2 where id = 1;
  QUERY PLAN  
--------------
 Delete on t2
   ->  Result
(2 rows)

delete from t2 where id = 1;
explain (COSTS OFF) delete from t2 where id > 1;
           QUERY PLAN            
---------------------------------
 Delete on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

delete from t2 where id > 1;
-- Before update trigger test.
alter table t2 add column count int;
insert into t2 values (1, 'John', 0);
CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TRIGGER update_count_trig BEFORE UPDATE ON t2 FOR ROW EXECUTE PROCEDURE update_count();
update t2 set name = 'Jane' where id = 1;
select * from t2;
 id | name | count 
----+------+-------
  1 | Jane |     1
(1 row)

-- CREATE INDEX
CREATE INDEX myidx on t2(name);
-- Insert with on conflict
insert into t2 values (1, 'foo') on conflict ON CONSTRAINT t2_pkey do update set id = t2.id+1;
select * from t2;
 id | name | count 
----+------+-------
  2 | Jane |     2
(1 row)

-- Joins (YB_TODO: if I move it below pushdown test, the test fails)
CREATE TABLE p1 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE TABLE p2 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p2 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
-- Merge join
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.a)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on p1 t1
               Remote Filter: (a <= 100)
   ->  Sort
         Sort Key: t2.a
         ->  Seq Scan on p2 t2
               Remote Filter: (a <= 100)
(10 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
  0 |  0 | 0000 |  0 |  0 | 0000
  6 |  6 | 0006 |  6 |  6 | 0006
 12 | 12 | 0012 | 12 | 12 | 0012
 18 | 18 | 0018 | 18 | 18 | 0018
 24 | 24 | 0024 | 24 | 24 | 0024
 30 |  5 | 0030 | 30 |  5 | 0030
 36 | 11 | 0036 | 36 | 11 | 0036
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 54 |  4 | 0054 | 54 |  4 | 0054
 60 | 10 | 0060 | 60 | 10 | 0060
 66 | 16 | 0066 | 66 | 16 | 0066
 72 | 22 | 0072 | 72 | 22 | 0072
 78 |  3 | 0078 | 78 |  3 | 0078
 84 |  9 | 0084 | 84 |  9 | 0084
 90 | 15 | 0090 | 90 | 15 | 0090
 96 | 21 | 0096 | 96 | 21 | 0096
(17 rows)

-- Hash join
SET enable_mergejoin = off;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 Hash Join
   Hash Cond: (t1.a = t2.a)
   ->  Seq Scan on p1 t1
         Remote Filter: (a <= 100)
   ->  Hash
         ->  Seq Scan on p2 t2
               Remote Filter: (a <= 100)
(7 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

-- Batched nested loop join
SET enable_hashjoin = off;
SET enable_seqscan = off;
SET enable_material = off;
SET yb_bnl_batch_size = 3;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on p1 t1
         Remote Filter: (a <= 100)
   ->  Index Scan using p2_pkey on p2 t2
         Remote Filter: (a <= 100)
(6 rows)

-- YB_TODO: Explain has a missing line Index Cond: (a = ANY (ARRAY[t1.a, $1, $2])) under Index Scan
SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

-- Update pushdown test.
CREATE TABLE single_row_decimal (k int PRIMARY KEY, v1 decimal, v2 decimal(10,2), v3 int);
CREATE FUNCTION next_v3(int) returns int language sql as $$
  SELECT v3 + 1 FROM single_row_decimal WHERE k = $1;
$$;
INSERT INTO single_row_decimal(k, v1, v2, v3) values (1,1.5,1.5,1), (2,2.5,2.5,2), (3,null, null,null);
SELECT * FROM single_row_decimal ORDER BY k;
 k | v1  |  v2  | v3
---+-----+------+----
 1 | 1.5 | 1.50 |  1
 2 | 2.5 | 2.50 |  2
 3 |     |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = v3 + 1 WHERE k = 1;
-- v2 should be rounded to 2 decimals.
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 3.055 | 3.06 |  2
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = 3 WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1  |  v2  | v3
---+------+------+----
 1 | 4.61 | 4.62 |  3
 2 |  2.5 | 2.50 |  2
 3 |      |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = next_v3(1) WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

-- Delete with returning
insert into t2 values (4), (5), (6);
delete from t2 where id > 2 returning id, name;
 id | name 
----+------
  5 | 
  6 | 
  4 | 
(3 rows)

-- YB_TODO: There's some issue with drop table
-- COPY FROM
CREATE TABLE myemp (id int primary key, name text);
COPY myemp FROM stdin;
SELECT * from myemp;
 id | name 
----+------
  1 | a
  2 | b
(2 rows)

CREATE TABLE myemp2(id int primary key, name text) PARTITION BY range(id);
CREATE TABLE myemp2_1_100 PARTITION OF myemp2 FOR VALUES FROM (1) TO (100);
CREATE TABLE myemp2_101_200 PARTITION OF myemp2 FOR VALUES FROM (101) TO (200);
COPY myemp2 FROM stdin;
SELECT * from myemp2_1_100;
 id | name 
----+------
  1 | a
(1 row)

SELECT * from myemp2_101_200;
 id  | name 
-----+------
 102 | b
(1 row)

-- Adding PK
create table test (id int);
insert into test values (1);
ALTER TABLE test ENABLE ROW LEVEL SECURITY;
CREATE POLICY test_policy ON test FOR SELECT USING (true);
alter table test add primary key (id);
create table test2 (id int);
insert into test2 values (1), (1);
alter table test2 add primary key (id);
ERROR:  duplicate key value violates unique constraint "test2"
-- Creating partitioned table
create table emp_par1(id int primary key, name text) partition by range(id);
CREATE TABLE emp_par1_1_100 PARTITION OF emp_par1 FOR VALUES FROM (1) TO (100);
create table emp_par2(id int primary key, name text) partition by list(id);
create table emp_par3(id int primary key, name text) partition by hash(id);
-- Adding FK
create table emp(id int unique);
create table address(emp_id int, addr text);
insert into address values (1, 'a');
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
ERROR:  insert or update on table "address" violates foreign key constraint "address_emp_id_fkey"
DETAIL:  Key (emp_id)=(1) is not present in table "emp".
insert into emp values (1);
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
-- Adding PK with pre-existing FK constraint
alter table emp add primary key (id);
alter table address add primary key (emp_id);
-- Add primary key with with pre-existing FK where confdelsetcols non nul
create table emp2 (id int, name text, primary key (id, name));
create table address2 (id int, name text, addr text,  FOREIGN KEY (id, name) REFERENCES emp2 ON DELETE SET NULL (name));
insert into emp2 values (1, 'a'), (2, 'b');
insert into address2 values (1, 'a', 'a'), (2, 'b', 'b');
delete from emp2 where id = 1;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 | b    | b
(2 rows)

alter table address2 add primary key (id);
delete from emp2 where id = 2;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 |      | b
(2 rows)

-- create database
CREATE DATABASE mytest;
-- drop database
DROP DATABASE mytest;
